
```go
`Индексы` — специальные объекты базы данных, предназначенные в основном для ускорения доступа к данным.
Важно понимать, что индекс, ускоряя доступ к данным, взамен требует определенных затрат на свое поддержание. При любой операции над проиндексированными данными — будь то вставка, удаление или обновление строк таблицы, — индексы, созданные для этой таблицы, должны быть перестроены
```

```go
`Частичные индексы`
Иногда возникает необходимость проиндексировать только часть строк таблицы. Обычно это связано с сильной неравномерностью распределения. Для этого при построении индекса добавляется `WHERE ...` с условием
```

```go
Forwarded (прямой) и inverted (инвертированный) индексы

Прямой индекс — это индекс, который хранит ссылки на документы или записи, содержащие определенные ключевые слова или значения. Прямой индекс используется для быстрого поиска документов по ключевым словам.

  Пример:
- Ключевое слово: "Go"
- Документы: [Document1, Document2, Document3]
Прямой индекс будет выглядеть следующим образом:

`Go -> [Document1, Document2, Document3]`

  Преимущества:
- Быстрый поиск по ключевым словам.
- Простота реализации.
  Недостатки:
- Требует больше места для хранения, так как каждый документ может быть связан с множеством ключевых слов.
- Менее эффективен для сложных запросов, таких как поиск по нескольким ключевым словам одновременно.


Инвертированный индекс — это индекс, который хранит ссылки на документы или записи, содержащие определенные ключевые слова или значения, но в обратном порядке. Вместо того чтобы хранить ссылки на документы для каждого ключевого слова, инвертированный индекс хранит ссылки на ключевые слова для каждого документа.

 Пример:
- Документ: Document1
- Ключевые слова: ["Go", "Programming", "Language"]

Инвертированный индекс будет выглядеть следующим образом:

`Document1 -> ["Go", "Programming", "Language"]`

  Преимущества:
- Более эффективен для сложных запросов, таких как поиск по нескольким ключевым словам одновременно.
- Меньше места для хранения, так как каждый документ связан только с его ключевыми словами.
  Недостатки:
- Более сложная реализация.
- Менее эффективен для простых запросов, таких как поиск по одному ключевому слову.
```

---
##  B-Tree


Индекс btree, пригоден для данных, которые можно отсортировать. Иными словами, для типа данных должны быть определены операторы >, >=, <, <= и =.

```
свойства:
- Они сбалансированы, то есть любую листовую страницу отделяет от корня одно и то же число внутренних страниц. Поэтому поиск любого значения занимает одинаковое время.  
- Они сильно ветвисты, то есть каждая страница (как правило, 8 КБ) содержит сразу много (сотни) TID-ов. За счет этого глубина B-деревьев получается небольшой; на практике до 4–5 для очень больших таблиц.  
- Данные в индексе упорядочены по неубыванию (как между страницами, так и внутри каждой страницы), а страницы одного уровня связаны между собой двунаправленным списком. Поэтому получить упорядоченный набор данных мы можем, просто проходя по списку в одну или в другую сторону, не возвращаясь каждый раз к корню.

```


![[Attachments/Pasted image 20240922182912.png]]

##### Поиск по неравенству для условия n <= 35

![[Attachments/Pasted image 20240922183247.png]]

##### Поиск по диапазону для условия 23 <= n <= 64
При поиске по диапазону «_выражение1 ≤ индексированное-поле ≤ выражение2_» находим значение по условию «_индексированное-поле = выражение1_», а затем двигаемся по листовым страницам, пока выполняется условие «_индексированное-поле ≤ выражение2_». Или наоборот: начинаем со второго выражения и двигаемся в другую сторону, пока не дойдем до первого.
![[Attachments/Pasted image 20240922183357.png]]

##### Порядок столбцов

Если индекс строится сразу по нескольким столбцам, то данные внутри страниц будут отсортированы сначала по первому полю, затем по второму и так далее.


---

## GIN

Расшифровывается как Generalized Inverted Index — это так называемый _обратный индекс_. Он работает с типами данных, значения которых не являются атомарными, а состоят из элементов. При этом индексируются не сами значения, а отдельные элементы; каждый элемент ссылается на те значения, в которых он встречается.

`Основная область применения метода gin — ускорение полнотекстового поиска`

![[Attachments/Pasted image 20240922185021.png]]

Вставка или обновление данных в GIN-индексе выполняется относительно медленно. Каждый документ обычно содержит много лексем, подлежащих индексированию. Поэтому при появлении или изменении одного-единственного документа приходится вносить массовые изменения в дерево индекса.

---

## Hash

использует хэш-таблицу для быстрого поиска данных. Хэш-индексы особенно эффективны для операций точного поиска (например, `SELECT * FROM table WHERE column = value`), так как они обеспечивают постоянное время доступа (O(1)) для таких операций.

```
Преимущества хэш-индексов
1. Быстрый поиск
2. Простота реализации

Недостатки хэш-индексов
1. Отсутствие поддержки диапазонных запросов
2. Коллизии
3. Размер хэш-таблицы (может привести к избыточному использованию памяти)
```

---

## GiST

 сокращение от «generalized search tree». Это сбалансированное дерево поиска, точно так же, как и рассмотренный ранее b-tree.
 Индекс b-tree жестко привязан к семантике сравнения: поддержка операторов «больше», «меньше», «равно» — это все, на что он способен. Но в современных базах хранятся и такие типы данных, для которых эти операторы просто не имеют смысла: геоданные, текстовые документы, картинки…

Идея R-дерева состоит в том, что плоскость разбивается на прямоугольники, которые в сумме покрывают все индексируемые точки. Индексная запись хранит прямоугольник, а предикат можно сформулировать так: «искомая точка лежит внутри данного прямоугольника»

![[Attachments/Pasted image 20240922184201.png]]

![[Attachments/Pasted image 20240922184223.png]]


---

## BRIN (Block Range Index)

```
идея BRIN не в том, чтобы быстро найти нужные строки, а в том, чтобы избежать просмотра заведомо ненужных. Это всегда неточный индекс: он вообще не содержит TID-ов табличных строк.
```

Таблица разбивается на _зоны_ (range) размером в несколько страниц (или блоков, что то же самое) — отсюда и название: Block Range Index, BRIN. Для каждой зоны в индексе сохраняется _сводная информация_ о данных в этой зоне. Как правило, это минимальное и максимальное значения, но бывает и иначе. Если при выполнении запроса, содержащего условие на столбец, искомые значения не попадают в диапазон, то всю зону можно смело пропускать; если же попадают — все строки во всех блоках зоны придется просмотреть и выбрать среди них подходящие.

![[Attachments/Pasted image 20240922185519.png]]

BRIN-индексы не поддерживают все типы запросов и операций так же эффективно, как традиционные индексы. Например, они менее эффективны для точных поисков (например, `WHERE column = value`).