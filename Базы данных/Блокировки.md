```
это механизмы, которые используются для управления доступом к данным и обеспечения целостности данных в многопользовательских средах. Они предотвращают одновременное изменение данных несколькими транзакциями, что может привести к несогласованности данных.
```

#### Основные типы блокировок

```go
`Общие блокировки / Shared Locks`
- Позволяют нескольким транзакциям читать данные одновременно, но запрещают изменение данных.
- Обычно используются для операций чтения.
```

```go
`Эксклюзивные блокировки / Exclusive Locks`
- Запрещают другим транзакциям читать или изменять данные, пока блокировка активна.
- Используются для операций записи, обновления.
```

#### Механизмы(виды) блокировок

```go
`Оптимистичные блокировки / Optimistic Locking`
- Предполагают, что конфликты редки, и проверяют их только при завершении транзакции.
- Если конфликт обнаружен, транзакция откатывается и повторяется.
```

```go
`Пессимистические блокировки / Pessimistic Locking`
- Предполагают, что конфликты часты, и блокируют данные сразу при начале транзакции.
- Обеспечивают более строгий контроль доступа, но могут привести к задержкам и блокировкам.
```

#### Уровни блокировок

```go
`Блокировки на уровне строк / Row-Level Locks`
- Блокируют отдельные строки в таблице.
- Обеспечивают высокую гранулярность и минимальное влияние на другие транзакции.
```

```go
`Блокировки на уровне страниц / Page-Level Locks`
- Блокируют целые страницы данных.
- Менее гранулярны, чем строковые блокировки, но могут быть более эффективны в некоторых случаях.
```

```go
`Блокировки на уровне таблиц / Table-Level Locks`
- Блокируют всю таблицу.
- Наименее гранулярны и могут существенно влиять на производительность, но легче в реализации.
```

#### Deadlocks

Ситуация, когда две или более транзакций ожидают друг друга для освобождения ресурсов.

Таблицы могут использоваться разными транзакциями в разном порядке и быть ими заблокированными. Внутренний процесс может обнаружить такую ситуацию и убить одну транзакцию. Выбор часто падает на маленькую транзакцию, которая изменила не очень много данных. Проблема здесь заключается в том, что большая транзакция могла быть вызвана фоновым процессом, а маленькая — клиентом, т. е. такой подход не учитывает бизнес — смысла транзакций. Как вариант, можно разбивать большую фоновую транзакцию на маленькие кусочки, либо регламентировать порядок работы с объектами. Также причиной deadlock'а может стать упомянутая выше эскалация блокировки.

